#!/usr/bin/env python3
"""
Agent module for Telegram Agent Bot
Handles LLM integration and response generation using OpenAI GPT-3.5-turbo
"""

import os
import logging
from typing import List, Dict, Any, Optional
import asyncio

try:
    import openai
except ImportError as e:
    logging.error(f"OpenAI package not installed: {e}")
    raise

logger = logging.getLogger(__name__)

class LLMAgent:
    """LLM Agent for generating intelligent responses"""
    
    def __init__(self, model: str = "gpt-3.5-turbo", max_tokens: int = 500, temperature: float = 0.7):
        self.model = model
        self.max_tokens = max_tokens
        self.temperature = temperature
        
        # Initialize OpenAI client
        openai.api_key = os.getenv('OPENAI_API_KEY')
        if not openai.api_key:
            logger.warning("OPENAI_API_KEY not found. LLM responses will be disabled.")
            self.enabled = False
        else:
            self.enabled = True
            logger.info(f"LLM Agent initialized with model: {model}")
    
    async def generate_response(
        self, 
        context: List[Dict[str, Any]], 
        user_message: str, 
        knowledge: List[str]
    ) -> str:
        """
        Generate response using OpenAI GPT-3.5-turbo
        
        Args:
            context: Conversation history as list of dicts with 'role' and 'content'
            user_message: Current user message
            knowledge: List of relevant knowledge snippets
            
        Returns:
            Generated response string
        """
        if not self.enabled:
            return self._fallback_response(user_message, knowledge)
        
        try:
            # Check if message is about MCP tools
            if self._is_mcp_related(user_message):
                return await self._handle_mcp_request(user_message, context, knowledge)
            
            # Prepare system prompt
            system_prompt = self._create_system_prompt()
            
            # Prepare context for LLM
            messages = [{"role": "system", "content": system_prompt}]
            
            # Add conversation context
            if context:
                # Limit context to last 6 messages to avoid token limits
                recent_context = context[-6:]
                for msg in recent_context:
                    if msg['role'] in ['user', 'assistant']:
                        messages.append({
                            "role": msg['role'],
                            "content": msg['content']
                        })
            
            # Add current user message
            messages.append({"role": "user", "content": user_message})
            
            # Generate response
            response = await self._call_openai_api(messages)
            
            logger.info(f"Generated LLM response for message: {user_message[:50]}...")
            return response
            
        except Exception as e:
            logger.error(f"Error generating LLM response: {e}")
            return self._fallback_response(user_message, knowledge)
    
    def _create_system_prompt(self) -> str:
        """Create system prompt for the LLM"""
        return """–¢—ã - –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ª–∏—á–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è Telegram. 

–¢–≤–æ–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º —á–µ—Ä–µ–∑ Google Calendar
- –û—Ç–ø—Ä–∞–≤–∫–∞ email-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —á–µ—Ä–µ–∑ Gmail  
- –ü–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ
- –ó–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤
- –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π

–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:
1. –û—Ç–≤–µ—á–∞–π –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ
2. –ë—É–¥—å –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–º –∏ –ø–æ–ª–µ–∑–Ω—ã–º
3. –ò—Å–ø–æ–ª—å–∑—É–π –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è –¥–ª—è –±–æ–ª–µ–µ —Ç–æ—á–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
4. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å–∏—Ç —Å–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ, –Ω–∞–ø–æ–º–Ω–∏—Ç—å –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å email - –ø—Ä–µ–¥–ª–æ–∂–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã
5. –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é - –∏—Å–ø–æ–ª—å–∑—É–π –ø–æ–∏—Å–∫
6. –ü–æ–º–Ω–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ —Å—Å—ã–ª–∞–π—Å—è –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è

–ö–æ–º–∞–Ω–¥—ã MCP:
- /calendar "–¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–∞—Ç–∞ –Ω–∞–∑–≤–∞–Ω–∏–µ" - –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏–π
- /email "–æ—Ç–ø—Ä–∞–≤–∏—Ç—å email@example.com: —Ç–µ–º–∞" - –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ email
- /search "–∑–∞–ø—Ä–æ—Å" - –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

–û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ, –Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ."""
    
    async def _call_openai_api(self, messages: List[Dict[str, str]]) -> str:
        """Call OpenAI API to generate response"""
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=messages,
                max_tokens=self.max_tokens,
                temperature=self.temperature
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            logger.error(f"OpenAI API error: {e}")
            raise
    
    def _is_mcp_related(self, message: str) -> bool:
        """Check if message is related to MCP tools"""
        message_lower = message.lower()
        
        mcp_keywords = [
            '–∫–∞–ª–µ–Ω–¥–∞—Ä—å', 'calendar', '—Å–æ–±—ã—Ç–∏–µ', '–≤—Å—Ç—Ä–µ—á–∞', '–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ',
            'email', '–ø–æ—á—Ç–∞', '–ø–∏—Å—å–º–æ', '–æ—Ç–ø—Ä–∞–≤–∏—Ç—å', '—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ',
            '–ø–æ–∏—Å–∫', 'search', '–Ω–∞–π—Ç–∏', '–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', '–ø–æ–≥–æ–¥–∞', '–∫—É—Ä—Å'
        ]
        
        return any(keyword in message_lower for keyword in mcp_keywords)
    
    async def _handle_mcp_request(self, message: str, context: List[Dict[str, Any]], knowledge: List[str]) -> str:
        """Handle MCP-related requests"""
        message_lower = message.lower()
        
        # Calendar related
        if any(word in message_lower for word in ['–∫–∞–ª–µ–Ω–¥–∞—Ä—å', 'calendar', '—Å–æ–±—ã—Ç–∏–µ', '–≤—Å—Ç—Ä–µ—á–∞', '–Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ']):
            return (
                "–Ø –º–æ–≥—É –ø–æ–º–æ—á—å —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º! üìÖ\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É:\n"
                "/calendar \"–¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–∞—Ç–∞ –Ω–∞–∑–≤–∞–Ω–∏–µ\"\n\n"
                "–ü—Ä–∏–º–µ—Ä—ã:\n"
                "‚Ä¢ /calendar \"–¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ 10.10.2025 –≤—Å—Ç—Ä–µ—á–∞ —Å –∫–ª–∏–µ–Ω—Ç–æ–º\"\n"
                "‚Ä¢ /calendar \"–¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –∑–∞–≤—Ç—Ä–∞ —Å–æ–≤–µ—â–∞–Ω–∏–µ\"\n"
                "‚Ä¢ /calendar \"–¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ —Å–µ–≥–æ–¥–Ω—è –∑–≤–æ–Ω–æ–∫\"\n\n"
                "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –¥–∞—Ç: DD.MM.YYYY, \"—Å–µ–≥–æ–¥–Ω—è\", \"–∑–∞–≤—Ç—Ä–∞\""
            )
        
        # Email related
        elif any(word in message_lower for word in ['email', '–ø–æ—á—Ç–∞', '–ø–∏—Å—å–º–æ', '–æ—Ç–ø—Ä–∞–≤–∏—Ç—å', '—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ']):
            return (
                "–Ø –º–æ–≥—É –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å email-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è! üìß\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É:\n"
                "/email \"–æ—Ç–ø—Ä–∞–≤–∏—Ç—å email@example.com: —Ç–µ–º–∞ –ø–∏—Å—å–º–∞\"\n\n"
                "–ü—Ä–∏–º–µ—Ä—ã:\n"
                "‚Ä¢ /email \"–æ—Ç–ø—Ä–∞–≤–∏—Ç—å reminder@example.com: –≤—Å—Ç—Ä–µ—á–∞ –∑–∞–≤—Ç—Ä–∞\"\n"
                "‚Ä¢ /email \"–æ—Ç–ø—Ä–∞–≤–∏—Ç—å boss@company.com: –æ—Ç—á–µ—Ç –≥–æ—Ç–æ–≤\"\n"
                "‚Ä¢ /email \"–æ—Ç–ø—Ä–∞–≤–∏—Ç—å friend@gmail.com: –∫–∞–∫ –¥–µ–ª–∞?\"\n\n"
                "–Ø –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏."
            )
        
        # Search related
        elif any(word in message_lower for word in ['–ø–æ–∏—Å–∫', 'search', '–Ω–∞–π—Ç–∏', '–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', '–ø–æ–≥–æ–¥–∞', '–∫—É—Ä—Å']):
            return (
                "–Ø –º–æ–≥—É –∏—Å–∫–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ! üîç\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É:\n"
                "/search \"–∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞\"\n\n"
                "–ü—Ä–∏–º–µ—Ä—ã:\n"
                "‚Ä¢ /search \"–ø–æ–≥–æ–¥–∞ –≤ –ú–æ—Å–∫–≤–µ\"\n"
                "‚Ä¢ /search \"–∫—É—Ä—Å –¥–æ–ª–ª–∞—Ä–∞\"\n"
                "‚Ä¢ /search \"–Ω–æ–≤–æ—Å—Ç–∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π\"\n"
                "‚Ä¢ /search \"—Ä–µ—Ü–µ–ø—Ç –±–æ—Ä—â–∞\"\n\n"
                "–Ø –Ω–∞–π–¥—É –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ –ø–æ–∫–∞–∂—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã."
            )
        
        # General MCP suggestion
        else:
            return (
                "–Ø –º–æ–≥—É –ø–æ–º–æ—á—å —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –∑–∞–¥–∞—á–∞–º–∏! ü§ñ\n\n"
                "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                "üìÖ /calendar - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º\n"
                "üìß /email - –æ—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π\n"
                "üîç /search - –ø–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏\n\n"
                "–ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –º–Ω–µ —á—Ç–æ-–Ω–∏–±—É–¥—å - —è –∑–∞–ø–æ–º–∏–Ω–∞—é –Ω–∞—à —Ä–∞–∑–≥–æ–≤–æ—Ä –∏ –º–æ–≥—É –ø–æ–º–æ—á—å!"
            )
    
    def _fallback_response(self, user_message: str, knowledge: List[str]) -> str:
        """Fallback response when LLM is not available"""
        message_lower = user_message.lower()
        
        # Simple keyword-based responses
        if any(word in message_lower for word in ['–ø—Ä–∏–≤–µ—Ç', 'hello', 'hi', '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π']):
            return "–ü—Ä–∏–≤–µ—Ç! –†–∞–¥ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å! –ö–∞–∫ –¥–µ–ª–∞? –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?"
        
        elif any(word in message_lower for word in ['—Å–ø–∞—Å–∏–±–æ', 'thanks', 'thank you']):
            return "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞! –í—Å–µ–≥–¥–∞ —Ä–∞–¥ –ø–æ–º–æ—á—å! üòä"
        
        elif any(word in message_lower for word in ['–∫–∞–ª–µ–Ω–¥–∞—Ä—å', 'calendar', '—Å–æ–±—ã—Ç–∏–µ']):
            return (
                "–Ø –º–æ–≥—É –ø–æ–º–æ—á—å —Å –∫–∞–ª–µ–Ω–¥–∞—Ä–µ–º! –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É:\n"
                "/calendar \"–¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ –¥–∞—Ç–∞ –Ω–∞–∑–≤–∞–Ω–∏–µ\""
            )
        
        elif any(word in message_lower for word in ['email', '–ø–æ—á—Ç–∞', '–ø–∏—Å—å–º–æ']):
            return (
                "–Ø –º–æ–≥—É –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å email! –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É:\n"
                "/email \"–æ—Ç–ø—Ä–∞–≤–∏—Ç—å email@example.com: —Ç–µ–º–∞\""
            )
        
        elif any(word in message_lower for word in ['–ø–æ–∏—Å–∫', 'search', '–Ω–∞–π—Ç–∏']):
            return (
                "–Ø –º–æ–≥—É –∏—Å–∫–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é! –ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É:\n"
                "/search \"–∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞\""
            )
        
        else:
            return (
                "–ü–æ–Ω—è–ª! –Ø –∑–∞–ø–æ–º–∏–Ω–∞—é –Ω–∞—à —Ä–∞–∑–≥–æ–≤–æ—Ä –∏ –≥–æ—Ç–æ–≤ –ø–æ–º–æ—á—å.\n\n"
                "–ú–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã:\n"
                "‚Ä¢ /calendar - –¥–ª—è —Å–æ–±—ã—Ç–∏–π\n"
                "‚Ä¢ /email - –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π\n"
                "‚Ä¢ /search - –¥–ª—è –ø–æ–∏—Å–∫–∞\n"
                "‚Ä¢ /help - –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏"
            )
    
    def get_stats(self) -> Dict[str, Any]:
        """Get LLM agent statistics"""
        return {
            'enabled': self.enabled,
            'model': self.model,
            'max_tokens': self.max_tokens,
            'temperature': self.temperature,
            'api_key_configured': bool(openai.api_key)
        }


# Global LLM agent instance
llm_agent = LLMAgent()


# Convenience function
async def generate_response(
    context: List[Dict[str, Any]], 
    user_message: str, 
    knowledge: List[str]
) -> str:
    """Convenience function to generate response"""
    return await llm_agent.generate_response(context, user_message, knowledge)


def get_llm_stats() -> Dict[str, Any]:
    """Convenience function to get LLM stats"""
    return llm_agent.get_stats()
